"""
Feast feature store definitions
================================
Registered via `feast apply` (run from the feature_store/ directory).
Used by train.py and predict.py via `store.get_historical_features()`.

Defines:
  - Entity:       "customer" — the primary key for all feature views
  - 2 FileSource: parquet files generated by src/data_prep.py
  - 2 FeatureView: RFM features + Behavioral features

Why 2 feature views instead of 1?
  In production, different feature groups often have different refresh
  cadences, owners, or data sources. Splitting them demonstrates how
  Feast joins multiple feature views at retrieval time — which is the
  core value of a feature store.
"""

from datetime import timedelta
from pathlib import Path

from feast import Entity, FeatureView, Field, FileSource, ValueType
from feast.types import Float64, Int64

# Resolve parquet paths relative to THIS file (feature_store/)
# Using absolute paths ensures Feast finds the files regardless of
# where the CLI or Python process is invoked from.
REPO_DIR = Path(__file__).resolve().parent
DATA_DIR = REPO_DIR / "data"

# ──────────────────────────────────────────────────────────────────────────────
# Entity
# ──────────────────────────────────────────────────────────────────────────────
# An Entity is the "primary key" that ties feature rows to real-world objects.
# Here, every feature row is keyed on customer_id.
customer = Entity(
    name="customer",
    join_keys=["customer_id"],
    value_type=ValueType.INT64,
    description="Unique retail customer identifier",
)

# ──────────────────────────────────────────────────────────────────────────────
# Data sources  (parquet files written by src/data_prep.py)
# ──────────────────────────────────────────────────────────────────────────────
# FileSource tells Feast where the underlying data lives and which column
# holds the event timestamp (needed for point-in-time-correct joins).
rfm_source = FileSource(
    path=str(DATA_DIR / "customer_rfm_features.parquet"),
    timestamp_field="event_timestamp",
)

behavior_source = FileSource(
    path=str(DATA_DIR / "customer_behavior_features.parquet"),
    timestamp_field="event_timestamp",
)

# ──────────────────────────────────────────────────────────────────────────────
# Feature View 1 — RFM (Recency, Frequency, Monetary, Tenure)
# ──────────────────────────────────────────────────────────────────────────────
# These are the classic customer-value signals used in almost every
# churn / CLV model.  Each field's dtype must match the parquet column type.
customer_rfm_fv = FeatureView(
    name="customer_rfm_features",
    entities=[customer],
    # ttl=0 means "features never expire" — appropriate for a static snapshot
    ttl=timedelta(days=0),
    schema=[
        Field(name="recency_days", dtype=Int64),
        Field(name="frequency", dtype=Int64),
        Field(name="monetary", dtype=Float64),
        Field(name="tenure_days", dtype=Int64),
    ],
    source=rfm_source,
)

# ──────────────────────────────────────────────────────────────────────────────
# Feature View 2 — Behavioral patterns
# ──────────────────────────────────────────────────────────────────────────────
# Captures how a customer shops: order size, product diversity, returns,
# and purchase cadence.  These complement RFM with richer engagement signals.
customer_behavior_fv = FeatureView(
    name="customer_behavior_features",
    entities=[customer],
    ttl=timedelta(days=0),
    schema=[
        Field(name="avg_order_value", dtype=Float64),
        Field(name="avg_basket_size", dtype=Float64),
        Field(name="n_unique_products", dtype=Int64),
        Field(name="return_rate", dtype=Float64),
        Field(name="avg_days_between_purchases", dtype=Float64),
    ],
    source=behavior_source,
)
